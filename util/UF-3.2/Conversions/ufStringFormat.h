#if !defined(STRFMTSTRINGFORMAT_H)
#define STRFMTSTRINGFORMAT_H

#include <string>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <functional>

#include "ufWin32Header.h"

namespace UF{

//! Formatting a string using streams.
namespace StrFmt {


  //! A Helper class for formatting a string
  /*!
  CLASS
    make_string

    Usage:
    \code
    // Assume n is a number.
    std::string s = make_string()
        << "Here is a number: "
        << std::setw(6) << n;
    \endcode

    \version 1.0

    \date 23-June-2003

    \author Andrew Maclean

    \par license
    This software is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    YOU, as the USER, take SOLE RESPONSIBILITY for, and are responsible for
    determining the FITNESS and APPLICABILITY of this software for a particular
    purpose. The author or any other person or entity are not liable in any way
    for the use or misuse of any program or software using this software.

    \todo

    \bug
  */
  class /*UF_CONVERSIONS_EXPORT*/ make_string
  {
    std::ostringstream os;
  public:
    //! Default constructor
    make_string ( void ) {};
    //! Stream the data.
    template < typename T >
    make_string &operator << ( const T& t )
    { os << t; return *this; }
    //! Return the string corresponding to the streamed data.
    operator std::string() const { return os.str(); }

  private:
    //! Copy constructor - disabled.
    make_string( const make_string & );
    //! Self assignment - disabled.
    make_string& operator = ( const make_string & );
  };

  //////////////////////////////////////////////////////////////////////////////
  ///  replace_crlf
  ///  Replace CRLF with LF.
  ///
  ///  @param  _First       _ForwardIter  A forward iterator addressing the position of the first
  ///            element in the source range.
  ///  @param  _Last        _ForwardIter A forward iterator addressing the position that is
  ///            one past the final element in the source range.
  ///
  ///  @return _ForwardIter An iterator pointing to one past the final element in the output range.
  ///    _Res=_First+(_Last-First-n), where n is the number of CRLF pairs replaced by a LF.
  ///
  ///  @remarks From a comment by Allan Odgaard (Duff@DIKU.KL), usage:
  ///  @code
  ///    p = replace_crlf<std::string::iterator>(s.begin(),s.end());
  ///    std::string t(s.begin(),p);
  ///    std::cout << "The result,t: " << t << std::endl;
  ///   // Or, alternatively:
  ///    s.erase(p,s.end());
  ///    std::cout << "The result,s: " << s << std::endl;
  ///  @endcode
  ///
  ///  @see
  ///
  ///  @author Andrew J. P. Maclean @date 02-23-2004
  //////// comment generated by Comment Maker from www.FeinSoftware.com /////////
  template < typename _ForwardIter >
  _ForwardIter replace_crlf (_ForwardIter _First, _ForwardIter _Last)
  {
    _ForwardIter _Res = _First;
    while (_First != _Last)
    {
      static const char crlf[] = {'\r','\n'};
      _ForwardIter eol = std::search(_First,_Last,crlf + 0,crlf + 2);
      _Res = std::copy(_First,eol,_Res);
      if ( eol == _Last )
        break;
      *_Res++ = '\n';
      _First = eol;
      std::advance(_First,2);
    }
    return _Res;
  }

  //! Convert any CRLF in a string to a LF.
  /*!

    \version 1.0


    \date 23-February-2004

    \author Andrew Maclean

    \par license
    This software is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    YOU, as the USER, take SOLE RESPONSIBILITY for, and are responsible for
    determining the FITNESS and APPLICABILITY of this software for a particular
    purpose. The author or any other person or entity are not liable in any way
    for the use or misuse of any program or software using this software.

    \todo

    \bug
  */
  struct /*UF_CONVERSIONS_EXPORT*/ Replace_CRLF_LF
  {
      //////////////////////////////////////////////////////////////////////////////
      ///  inline public operator ()
      ///  Converts any CRLF in a string to a LF.
      ///
      ///  @param  s    std::string & the string
      ///
      ///  @return void
      ///
      ///  @remarks Converts any CRLF in a string to a LF.
      ///
      ///  @see
      ///
      ///  @author Andrew J. P. Maclean @date 02-23-2004
      //////// comment generated by Comment Maker from www.FeinSoftware.com /////////
      void operator () (std::string & s )
      {
        std::string::iterator p = StrFmt::replace_crlf(s.begin(),s.end());
        s.erase(p,s.end());
      }
  };

  //! Convert CRLF or CR to LF in a string.
  /*!

    \version 1.0


    \date 23-February-2004

    \author Andrew Maclean

    \par license
    This software is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    YOU, as the USER, take SOLE RESPONSIBILITY for, and are responsible for
    determining the FITNESS and APPLICABILITY of this software for a particular
    purpose. The author or any other person or entity are not liable in any way
    for the use or misuse of any program or software using this software.

    \todo

    \bug
  */
  struct /*UF_CONVERSIONS_EXPORT*/ ToLF
  {
    ToLF ( void ):
      CR('\r')
      , LF('\n')
      , CRLF("\r\n")
      {}

      //////////////////////////////////////////////////////////////////////////////
      ///  inline public operator ()
      ///  Convert CRLF or CR to LF in a string.
      ///
      ///  @param  s    std::string & the string
      ///
      ///  @return void
      ///
      ///  @remarks Convert CRLF or CR to LF in a string.
      ///
      ///  @see
      ///
      ///  @author Andrew J. P. Maclean @date 02-23-2004
      //////// comment generated by Comment Maker from www.FeinSoftware.com /////////
      void operator () (std::string & s )
      {
        if ( s.empty() ) return;
        std::size_t i;
        // Replace CRLF with LF
        while ( (i = s.find(CRLF)) != std::string::npos )  s = s.replace(i,CRLF.size(),1,LF);
        // Replace any CR's with a LF.
        std::replace_if(s.begin(),s.end(),std::bind2nd(std::equal_to<char>(),CR),LF);
      }

  private:
    char CR;
    char LF;
    std::string CRLF;
  };

  //! Convert CRLF or LF to CR in a string.
  /*!

    \version 1.0


    \date 23-February-2004

    \author Andrew Maclean

    \par license
    This software is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    YOU, as the USER, take SOLE RESPONSIBILITY for, and are responsible for
    determining the FITNESS and APPLICABILITY of this software for a particular
    purpose. The author or any other person or entity are not liable in any way
    for the use or misuse of any program or software using this software.

    \todo

    \bug
  */
  struct /*UF_CONVERSIONS_EXPORT*/ ToCR
  {
    ToCR ( void ):
      CR('\r')
      , LF('\n')
      , CRLF("\r\n")
      {};

      //////////////////////////////////////////////////////////////////////////////
      ///  inline public operator ()
      ///  Convert CRLF or LF to CR in a string.
      ///
      ///  @param  s    std::string & the string
      ///
      ///  @return void
      ///
      ///  @remarks Converts CRLF or LF to CR in a string.
      ///
      ///  @see
      ///
      ///  @author Andrew J. P. Maclean @date 02-23-2004
      //////// comment generated by Comment Maker from www.FeinSoftware.com /////////
      void operator () (std::string & s )
      {
        if ( s.empty() ) return;
        std::size_t i;
        // Replace CRLF with CR
        while ( (i = s.find(CRLF)) != std::string::npos )  s = s.replace(i,CRLF.size(),1,CR);
        // Replace any LF's with a CR.
        std::replace_if(s.begin(),s.end(),std::bind2nd(std::equal_to<char>(),LF),CR);
      }

  private:
    char CR;
    char LF;
    std::string CRLF;
  };

  //! Convert CR or LF in a string to CRLF.
  /*!

    \version 1.0


    \date 23-February-2004

    \author Andrew Maclean

    \par license
    This software is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    YOU, as the USER, take SOLE RESPONSIBILITY for, and are responsible for
    determining the FITNESS and APPLICABILITY of this software for a particular
    purpose. The author or any other person or entity are not liable in any way
    for the use or misuse of any program or software using this software.

    \todo

    \bug
  */
  struct /*UF_CONVERSIONS_EXPORT*/ ToCRLF
  {
    ToCRLF ( void ):
      CR('\r')
      , LF('\n')
      , CRLF("\r\n")
      {}

      //////////////////////////////////////////////////////////////////////////////
      ///  inline public operator ()
      ///  Convert CR or LF in a string to CRLF.
      ///
      ///  @param  s    std::string & the string
      ///
      ///  @return void
      ///
      ///  @remarks Converts CR or LF in a string to CRLF.
      ///
      ///  @see
      ///
      ///  @author Andrew J. P. Maclean @date 02-23-2004
      //////// comment generated by Comment Maker from www.FeinSoftware.com /////////
      void operator () (std::string & s )
      {
        if ( s.empty() ) return;
        StrFmt::ToLF()(s);
        std::string t;
        t.clear();
        for ( std::size_t i = 0; i < s.size(); ++i )
        {
          if ( s[i] != LF )
            t += s[i];
          else
            t += CRLF;
        }
        s = t;
      }

  private:
    char CR;
    char LF;
    std::string CRLF;
  };

} // StrFmt

} // UF

#endif // STRFMTSTRINGFORMAT_H
